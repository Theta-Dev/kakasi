use std::{collections::HashMap, path::Path};

fn parse_dict<P: AsRef<Path>>(records: &mut Records, file: P) {
    let content = std::fs::read_to_string(file).unwrap();
    content
        .lines()
        .for_each(|line| parse_dict_ln(records, line));
}

fn parse_dict_ln(records: &mut Records, line: &str) {
    // Skip comments
    if line.starts_with(";;") {
        return;
    }

    let mut token = line.split_ascii_whitespace();
    let reading = token.next();
    let kanji = token.next();
    let context = token.collect::<Vec<_>>();

    if let (Some(mut reading), Some(kanji)) = (reading, kanji) {
        if reading.is_empty() || kanji.is_empty() {
            panic!("could not parse line: `{}`", line);
        }

        let (i_last, last) = reading.char_indices().last().unwrap();
        let tail = if last.is_ascii_alphabetic() {
            reading = &reading[0..i_last];
            Some(last)
        } else {
            None
        };
        updaterec(records, kanji, reading, tail, &context);
    } else {
        panic!("could not parse line: `{}`", line);
    }
}

static CLETTERS: phf::Map<char, &[&str]> = phf::phf_map!(
    'a' => &["あ", "ぁ", "っ", "わ", "ゎ"],
    'i' => &["い", "ぃ", "っ", "ゐ"],
    'u' => &["う", "ぅ", "っ"],
    'e' => &["え", "ぇ", "っ", "ゑ"],
    'o' => &["お", "ぉ", "っ"],
    'k' => &["か", "ゕ", "き", "く", "け", "ゖ", "こ", "っ"],
    'g' => &["が", "ぎ", "ぐ", "げ", "ご", "っ"],
    's' => &["さ", "し", "す", "せ", "そ", "っ"],
    'z' => &["ざ", "じ", "ず", "ぜ", "ぞ", "っ"],
    'j' => &["ざ", "じ", "ず", "ぜ", "ぞ", "っ"],
    't' => &["た", "ち", "つ", "て", "と", "っ"],
    'd' => &["だ", "ぢ", "づ", "で", "ど", "っ"],
    'c' => &["ち", "っ"],
    'n' => &["な", "に", "ぬ", "ね", "の", "ん"],
    'h' => &["は", "ひ", "ふ", "へ", "ほ", "っ"],
    'b' => &["ば", "び", "ぶ", "べ", "ぼ", "っ"],
    'f' => &["ふ", "っ"],
    'p' => &["ぱ", "ぴ", "ぷ", "ぺ", "ぽ", "っ"],
    'm' => &["ま", "み", "む", "め", "も"],
    'y' => &["や", "ゃ", "ゆ", "ゅ", "よ", "ょ"],
    'r' => &["ら", "り", "る", "れ", "ろ"],
    'w' => &["わ", "ゐ", "ゑ", "ゎ", "を", "っ"],
    'v' => &["ゔ"],
);

static TEST_MAP: phf::Map<&str, &[(&str, &[&str])]> = phf::phf_map!(
    "a" => &[("", &[])],
);

type Records = HashMap<String, Vec<(String, Vec<String>)>>;

fn updaterec(
    records: &mut Records,
    kanji: &str,
    reading: &str,
    tail: Option<char>,
    context: &[&str],
) {
    match tail {
        Some(tail) => {
            if let Some(cltrs) = CLETTERS.get(&tail) {
                cltrs.iter().for_each(|c| {
                    updaterec(
                        records,
                        &format!("{}{}", kanji, c),
                        &format!("{}{}", reading, c),
                        None,
                        context,
                    )
                });
            } else {
                panic!("invalid tail: {}", tail);
            }
        }
        None => {
            let entry = records.entry(kanji.to_owned()).or_default();
            entry.push((
                reading.to_owned(),
                context.iter().map(|x| (*x).to_owned()).collect(),
            ));
        }
    }
}

fn main() {
    let mut records = Records::default();
    parse_dict(&mut records, Path::new("dict/kakasidict.utf8"));
    // parse_dict(&mut records, Path::new("dict/unidict_adj.utf8"));
    // parse_dict(&mut records, Path::new("dict/unidict_noun.utf8"));

    let mut map = phf_codegen::Map::<&str>::new();

    for (kanji, entry) in &records {
        let mut code_readings = entry
            .iter()
            .map(|(reading, context)| {
                let mut code_context = context
                    .iter()
                    .map(|c| format!(r#""{}", "#, c))
                    .collect::<String>();
                code_context.pop();
                code_context.pop();
                format!(r#"("{}", &[{}]), "#, reading, code_context)
            })
            .collect::<String>();
        code_readings.pop();
        code_readings.pop();

        let code_entry = format!(r#"&[{}]"#, code_readings);
        map.entry(kanji, &code_entry);
    }

    let code_header = r#"// This file is automatically generated using the kakasi-codegen crate. DO NOT EDIT.
"#;
    let code = format!(
        "{}\n#[rustfmt::skip]\npub(crate) static KANWA_DICT: phf::Map<&str, &[(&str, &[&str])]> = {};\n",
        code_header,
        map.build().to_string()
    );
    std::fs::write("test.rs", &code).unwrap();
}
